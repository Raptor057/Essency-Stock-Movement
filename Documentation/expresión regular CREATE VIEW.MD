# Expresi√≥n Regular `CREATE VIEW`
**expresi√≥n regular** que valida un **`CREATE VIEW` en SQLite**, asegurando que siga la sintaxis correcta y respete las palabras reservadas:

```regex
^(?<StartViewQuery>CREATE\s+VIEW)\s+(?<NameOfView>[A-Za-z_][A-Za-z0-9_]*)\s+(?<QueryAlias>AS)\s*\n(?<StartQuery>SELECT)\s+(?<Columns>.+?)\s*\n(?<QueryFrom>FROM)\s+(?<TableName>[A-Za-z_][A-Za-z0-9_]*)\s*(?<Joins>(?:\s+JOIN\s+[A-Za-z_][A-Za-z0-9_]*\s+ON\s+.+?)*)?\s*(?<WhereClause>(?:\s+WHERE\s+.+?)?)\s*(?<GroupByClause>(?:\s+GROUP\s+BY\s+.+?)?)\s*(?<OrderByClause>(?:\s+ORDER\s+BY\s+.+?)?)\s*(?<EndOfQuery>;)$

```

----------

### **üìå Explicaci√≥n de los grupos nombrados:**

1.  **`StartViewQuery`** ‚Üí `CREATE VIEW` (debe iniciar con esta palabra clave).
2.  **`NameOfView`** ‚Üí El nombre de la vista (solo letras, n√∫meros y `_`, sin comenzar con un n√∫mero).
3.  **`QueryAlias`** ‚Üí `AS` (obligatorio para definir la vista).
4.  **`StartQuery`** ‚Üí `SELECT` (debe venir despu√©s de `AS`).
5.  **`Columns`** ‚Üí Lista de columnas seleccionadas, permitiendo `*` o columnas separadas por `,`.
6.  **`QueryFrom`** ‚Üí `FROM` seguido del **nombre de la tabla principal**.
7.  **`Joins`** _(opcional)_ ‚Üí `JOIN ... ON ...` para validar `INNER JOIN`, `LEFT JOIN`, etc.
8.  **`WhereClause`** _(opcional)_ ‚Üí `WHERE` con condiciones.
9.  **`GroupByClause`** _(opcional)_ ‚Üí `GROUP BY` con columnas de agrupaci√≥n.
10.  **`OrderByClause`** _(opcional)_ ‚Üí `ORDER BY` para ordenar resultados.
11.  **`EndOfQuery`** ‚Üí `;` (debe finalizar con punto y coma).

----------

### **üîç Ejemplos de consultas v√°lidas:**

‚úî **Consulta simple:**

```sql
CREATE VIEW MyView AS 
SELECT id, name 
FROM Users;

```

‚úî **Consulta con `JOIN`:**

```sql
CREATE VIEW UserOrders AS 
SELECT U.id, U.name, O.order_id, O.amount 
FROM Users U 
INNER JOIN Orders O ON U.id = O.user_id;

```

‚úî **Consulta con `WHERE`, `GROUP BY`, y `ORDER BY`:**

```sql
CREATE VIEW SalesReport AS 
SELECT S.date, SUM(S.amount) AS TotalSales 
FROM Sales S 
WHERE S.date > '2024-01-01' 
GROUP BY S.date 
ORDER BY S.date DESC;

```

----------

### **üö® Casos incorrectos que NO pasar√≠an la validaci√≥n:**

‚ùå **Falta `AS` despu√©s de `CREATE VIEW`**

```sql
CREATE VIEW MyView
SELECT id, name FROM Users;

```

‚ùå **Falta `FROM` en la consulta**

```sql
CREATE VIEW MyView AS 
SELECT id, name;

```

‚ùå **No tiene punto y coma (`;`) al final**

```sql
CREATE VIEW MyView AS 
SELECT id, name 
FROM Users

```

----------

### **üìå Beneficios de esta expresi√≥n regular:**

‚úÖ **Valida la estructura completa del `CREATE VIEW`**.  
‚úÖ **Permite nombres de vistas/tablas con letras, n√∫meros y `_`**.  
‚úÖ **Soporta `JOIN`, `WHERE`, `GROUP BY`, `ORDER BY` opcionales**.  
‚úÖ **Asegura que el query termina con `;`**.  
‚úÖ **Evita consultas mal formadas que puedan generar errores**.

----------

### **üî• ¬øC√≥mo usar esta validaci√≥n en Kotlin?**

Si quieres validar el query antes de ejecutarlo en **SQLite**, puedes hacer esto:

```kotlin
val regex = Regex(
    "^(?<StartViewQuery>CREATE\\s+VIEW)\\s+(?<NameOfView>[A-Za-z_][A-Za-z0-9_]*)\\s+(?<QueryAlias>AS)\\s*\\n(?<StartQuery>SELECT)\\s+(?<Columns>.+?)\\s*\\n(?<QueryFrom>FROM)\\s+(?<TableName>[A-Za-z_][A-Za-z0-9_]*)\\s*(?<Joins>(?:\\s+JOIN\\s+[A-Za-z_][A-Za-z0-9_]*\\s+ON\\s+.+?)*)?\\s*(?<WhereClause>(?:\\s+WHERE\\s+.+?)?)\\s*(?<GroupByClause>(?:\\s+GROUP\\s+BY\\s+.+?)?)\\s*(?<OrderByClause>(?:\\s+ORDER\\s+BY\\s+.+?)?)\\s*(?<EndOfQuery>;)$"
)

fun validateViewQuery(query: String): Boolean {
    return regex.matches(query)
}

// Ejemplo de uso:
val query = """
    CREATE VIEW UserOrders AS 
    SELECT U.id, U.name, O.order_id, O.amount 
    FROM Users U 
    INNER JOIN Orders O ON U.id = O.user_id;
""".trimIndent()

if (validateViewQuery(query)) {
    println("‚úÖ Query v√°lido")
} else {
    println("‚ùå Query inv√°lido")
}

```

----------

### **üöÄ Conclusi√≥n**

Ahora tienes una **expresi√≥n regular robusta** para validar `CREATE VIEW` en SQLite, asegurando que respete las palabras clave y la sintaxis. Puedes usarla en **Kotlin** antes de ejecutar un query y evitar errores de SQL mal estructurados. üöÄüî•